// built with:
//   gcc -no-pie -fstack-protector-all -O0 -m32 -ggdb3 -o brutefork brutefork.c

#include <arpa/inet.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define PORT 1337

bool check_pass(const char *pass);
void shell(void);
void fatal(const char *msg);
void error(const char *msg);
void cleanup_child(int signal);

void handle(void) {
    char buf[100];

    printf("Input password: ");
    read(STDIN_FILENO, buf, 0x100);

    if (check_pass(buf)) {
        printf("Authenticated. Here's your shell:\n");
        shell();
    } else {
        printf("Authentication failed!\n");
    }
}

int main(void) {
    // prevent buffering input and output
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);

    // handle terminating children
    signal(SIGCHLD, cleanup_child);

    // create socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
        error("socket");

    // make port reusable
    int opt_yes = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt_yes, sizeof opt_yes))
        error("setsockopt");

    // set address (any) and port (PORT)
    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    // prepare for accepting connections
    if (bind(sockfd, (struct sockaddr *)&addr, sizeof addr))
        error("bind");
    if (listen(sockfd, 8))
        error("listen");

    while (1) {
        // wait for new connection
        int clientfd = accept(sockfd, NULL, NULL);
        if (clientfd < 0)
            error("accept");

        // fork: parent waits for next connection, child handles connection
        pid_t child = fork();
        if (child < 0) {
            error("fork");

        } else if (child == 0) {
            // in child

            // use connection for standard input and output
            close(sockfd);
            dup2(clientfd, STDIN_FILENO);
            dup2(clientfd, STDOUT_FILENO);
            dup2(clientfd, STDERR_FILENO);

            handle();
            return EXIT_SUCCESS;

        } else {
            // in parent

            close(clientfd);
        }
    }
    close(sockfd);

    return EXIT_SUCCESS;
}

bool check_pass(const char *pass) {
    return false;
}

void shell(void) {
    execl("/bin/sh", "sh", (char *)NULL);
}

void fatal(const char *msg) {
    printf("ERROR: %s\n", msg);
    printf("Please contact an admin.\n");
    exit(EXIT_FAILURE);
}

void error(const char *msg) {
    perror(msg);
    printf("Please contact an admin.\n");
    exit(EXIT_FAILURE);
}

void cleanup_child(int signal) {
    waitpid(0, NULL, WNOHANG);
}
